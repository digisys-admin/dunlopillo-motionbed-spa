<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover, minimal-ui" />
    <meta charset="utf-8" />
    
    <!-- 모바일 최적화 메타 태그 -->
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- PWA 매니페스트 -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#1e40af">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="apple-mobile-web-app-title" content="던롭필로 SPA">
    
    <!-- 폰트 최적화: Pretendard 폰트 (안정적인 CDN 경로) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preload" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/variable/pretendardvariable.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/variable/pretendardvariable.css"></noscript>
    
    <!-- 🚀 핵심 이미지 네이티브 프리로딩 (가장 빠른 방법) -->
    <link rel="preload" as="image" href="assets/pics/dunlopillo_logo.png">
    <link rel="preload" as="image" href="assets/pics/p2_bed.png">
    <link rel="preload" as="image" href="assets/pics/p3_pic1.png">
    <link rel="preload" as="image" href="assets/pics/p4_pic1.png">
    <link rel="preload" as="image" href="assets/pics/home-icon.png">
    
    <!-- 메인 스타일시트 -->
    <link rel="stylesheet" href="styles.css" />
    
    <!-- 프리로딩 스크린 스타일 -->
    <style>
      .preloading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        transition: opacity 0.5s ease-out;
      }

      .preloading-overlay.fade-out {
        opacity: 0;
        pointer-events: none;
      }

      .preloading-container {
        text-align: center;
        color: white;
        font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      }

      .preloading-logo {
        width: 200px;
        height: 45px;
        margin: 0 auto 40px;
        background: white;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: #1e40af;
        font-size: 18px;
      }

      .preloading-progress {
        width: 400px;
        height: 8px;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        overflow: hidden;
        margin: 0 auto 20px;
        position: relative;
      }

      .preloading-fill {
        height: 100%;
        background: linear-gradient(90deg, #60a5fa, #93c5fd);
        border-radius: 4px;
        transition: width 0.3s ease-out;
        width: 0%;
        position: relative;
      }

      .preloading-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
        animation: shimmer 1.5s infinite;
      }

      @keyframes shimmer {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
      }

      .preloading-text {
        font-size: 18px;
        margin-bottom: 10px;
        font-weight: 500;
      }

      .preloading-details {
        font-size: 14px;
        opacity: 0.8;
        margin-bottom: 30px;
      }

      .preloading-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        max-width: 400px;
        margin: 0 auto;
      }

      .stat-item {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 8px;
        backdrop-filter: blur(10px);
      }

      .stat-number {
        font-size: 24px;
        font-weight: bold;
        color: #60a5fa;
      }

      .stat-label {
        font-size: 12px;
        opacity: 0.8;
        margin-top: 5px;
      }

      /* 반응형 디자인 */
      @media (max-width: 768px) {
        .preloading-progress {
          width: 300px;
        }
        
        .preloading-stats {
          grid-template-columns: 1fr;
          gap: 10px;
        }
      }
      
      /* 🚀 이미지 로딩 최적화 CSS */
      img {
        image-rendering: -webkit-optimize-contrast; /* 렌더링 최적화 */
        image-rendering: crisp-edges; /* 선명도 우선 */
        transform: translateZ(0); /* 하드웨어 가속 */
        will-change: transform; /* GPU 레이어 생성 */
      }
      
      /* 이미지 전환 애니메이션 부드럽게 */
      .screen img {
        transition: opacity 0.1s ease-out; /* 빠른 페이드인 */
      }
      
      /* 브라우저 캐시 최대화 */
      .preloaded-image {
        position: absolute;
        left: -9999px;
        top: -9999px;
        opacity: 0;
        pointer-events: none;
        z-index: -1;
      }
    </style>
    
    <title>Dunlopillo SPA</title>
    
    <!-- URL 경로 기반 디바이스 ID 핸들러 (Fully Kiosk 호환) -->
    <script src="device-id-handler.js"></script>
  </head>
  <body>
    <!-- 프리로딩 스크린 -->
    <div id="preloadingScreen" class="preloading-overlay">
      <div class="preloading-container">
        <div class="preloading-logo">DUNLOPILLO</div>
        
        <div class="preloading-progress">
          <div id="preloadingFill" class="preloading-fill"></div>
        </div>
        
        <div id="preloadingText" class="preloading-text">이미지 프리로딩 시작...</div>
        <div id="preloadingDetails" class="preloading-details">
          잠시만 기다려주세요
        </div>
        
        <div class="preloading-stats">
          <div class="stat-item">
            <div id="statLoaded" class="stat-number">0</div>
            <div class="stat-label">로드 완료</div>
          </div>
          <div class="stat-item">
            <div id="statTotal" class="stat-number">0</div>
            <div class="stat-label">전체 이미지</div>
          </div>
          <div class="stat-item">
            <div id="statProgress" class="stat-number">0%</div>
            <div class="stat-label">진행률</div>
          </div>
        </div>
      </div>
    </div>

    <!-- 디버그 정보 표시 (임시) - screen-container 밖에서 항상 표시 -->
    <!-- 
    <div id="debugInfo" style="position: fixed; top: 20px; left: 20px; background: rgba(255,0,0,0.9); color: white; padding: 8px; border-radius: 5px; font-size: 12px; z-index: 99999; font-family: monospace; font-weight: bold;">
      크기: <span id="screenSize">확인중...</span>
    </div>
    -->
    
    <!-- 글로벌 구조: 전체 바탕(찐한 회색) + 화면(1280x800 옅은 회색) -->
    <div class="screen-container" id="app">
      <!-- 여기에 각 페이지 컨텐츠가 렌더링됩니다 -->
    </div>
    
    <!-- JavaScript 파일들 - 순서 중요! -->
    <script src="survey-data-manager.js"></script>
    <script src="survey-data.js"></script>
    <script src="screens.js"></script>
    
    <!-- 간단한 이미지 프리로더 -->
    <script>
      // 프리로딩 상태 관리
      let preloadStartTime = Date.now();
      let mainAppStarted = false;

      // 로딩 스크린 업데이트
      function updatePreloadingScreen(loaded, total, currentImage, progress) {
        const preloadingFill = document.getElementById('preloadingFill');
        const preloadingText = document.getElementById('preloadingText');
        const preloadingDetails = document.getElementById('preloadingDetails');
        const statLoaded = document.getElementById('statLoaded');
        const statTotal = document.getElementById('statTotal');
        const statProgress = document.getElementById('statProgress');

        if (preloadingFill) preloadingFill.style.width = `${progress}%`;
        if (preloadingText) preloadingText.textContent = `이미지 로딩 중... ${progress}%`;
        if (preloadingDetails) {
          const elapsed = Math.round((Date.now() - preloadStartTime) / 1000);
          preloadingDetails.textContent = `${loaded}/${total} 완료 (${elapsed}초 경과)`;
        }
        if (statLoaded) statLoaded.textContent = loaded;
        if (statTotal) statTotal.textContent = total;
        if (statProgress) statProgress.textContent = `${progress}%`;
      }

      // 프리로딩 완료 처리
      function onPreloadingComplete(loaded, failed) {
        const totalTime = Math.round((Date.now() - preloadStartTime) / 1000);
        console.log(`🎉 프리로딩 완료: 성공 ${loaded}개, 실패 ${failed}개, ${totalTime}초 소요`);
        
        setTimeout(() => {
          // 로딩 스크린 페이드아웃
          const preloadingScreen = document.getElementById('preloadingScreen');
          if (preloadingScreen) {
            preloadingScreen.classList.add('fade-out');
            
            // 페이드아웃 완료 후 메인 앱 시작
            setTimeout(() => {
              preloadingScreen.style.display = 'none';
              startMainApp();
            }, 500);
          } else {
            startMainApp();
          }
        }, 1000); // 1초 더 표시
      }

      // 메인 앱 시작
      function startMainApp() {
        if (mainAppStarted) return;
        mainAppStarted = true;
        
        console.log('🚀 메인 앱 시작!');
        
        // 기존 앱 초기화 - MotionBedApp 인스턴스 생성
        if (typeof MotionBedApp !== 'undefined') {
          MotionBedApp.getInstance();
        } else {
          console.warn('⚠️ MotionBedApp을 찾을 수 없습니다');
        }
      }

      // 🚀 강화된 이미지 프리로더 (메모리 캐시 + 참조 유지)
      let imageCache = new Map(); // 이미지 객체 캐시
      
      async function startSimpleImagePreloading() {
        console.log('🚀 강화된 이미지 프리로딩 시작!');
        preloadStartTime = Date.now();
        
        if (!window.IMG) {
          console.error('❌ IMG 객체를 찾을 수 없습니다');
          setTimeout(() => onPreloadingComplete(0, 0), 1000);
          return;
        }

        const images = Object.entries(window.IMG).map(([key, url]) => ({ key, url }));
        console.log(`📊 총 ${images.length}개 이미지 발견`);
        
        let loadedCount = 0;
        let failedCount = 0;
        
        // 프로그레스 업데이트 함수
        function updateProgress() {
          const total = images.length;
          const completed = loadedCount + failedCount;
          const progress = total > 0 ? Math.round((completed / total) * 100) : 0;
          
          updatePreloadingScreen(loadedCount, total, '진행 중...', progress);
        }
        
        // 강화된 단일 이미지 로드 함수 (메모리 캐시 + 디코딩)
        function loadSingleImage(imageInfo) {
          return new Promise((resolve, reject) => {
            const { key, url } = imageInfo;
            const img = new Image();
            
            const startTime = Date.now();
            
            // 🔥 중요: 이미지 디코딩 최적화
            img.decoding = 'async'; // 비동기 디코딩으로 성능 향상
            img.loading = 'eager';  // 즉시 로딩
            
            const timeout = setTimeout(() => {
              failedCount++;
              console.warn(`⏰ ${key} 타임아웃 (30초)`);
              updateProgress();
              reject(new Error(`Timeout: ${key}`));
            }, 30000);
            
            img.onload = () => {
              clearTimeout(timeout);
              const loadTime = Date.now() - startTime;
              
              // 🚀 메모리 캐시에 저장 (DOM 참조 유지)
              imageCache.set(key, img);
              imageCache.set(url, img); // URL로도 접근 가능
              
              loadedCount++;
              console.log(`✅ ${key} 로드 완료 (${loadTime}ms) - 캐시 저장됨`);
              updateProgress();
              
              // 🔥 추가 최적화: 이미지 디코딩 완료 확인
              if (img.decode) {
                img.decode().then(() => {
                  console.log(`🎯 ${key} 디코딩 완료 - 즉시 표시 가능`);
                  resolve();
                }).catch(() => {
                  console.log(`⚠️ ${key} 디코딩 실패하지만 로드는 성공`);
                  resolve();
                });
              } else {
                resolve();
              }
            };
            
            img.onerror = () => {
              clearTimeout(timeout);
              const loadTime = Date.now() - startTime;
              failedCount++;
              console.warn(`❌ ${key} 로드 실패 (${loadTime}ms)`);
              updateProgress();
              reject(new Error(`Failed: ${key}`));
            };
            
            // 실제 경로 처리
            let actualUrl = url;
            if (url.startsWith('assets/')) {
              actualUrl = url; // 메인 페이지에서는 그대로 사용
            }
            
            img.src = actualUrl;
          });
        }
        
        // 배치 로딩 (5개씩)
        const batchSize = 5;
        const batches = [];
        
        for (let i = 0; i < images.length; i += batchSize) {
          batches.push(images.slice(i, i + batchSize));
        }
        
        console.log(`📦 ${batches.length}개 배치로 로딩 시작`);
        
        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          console.log(`🔄 배치 ${i + 1}/${batches.length} 시작 (${batch.length}개 이미지)`);
          
          const promises = batch.map(imageInfo => 
            loadSingleImage(imageInfo).catch(() => {
              // 실패해도 계속 진행
            })
          );
          
          await Promise.allSettled(promises);
          
          // 배치 간 100ms 지연
          if (i < batches.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }
        
        const totalTime = Math.round((Date.now() - preloadStartTime) / 1000);
        console.log(`🎉 프리로딩 완료! 총 ${totalTime}초 소요`);
        console.log(`📊 성공: ${loadedCount}개, 실패: ${failedCount}개`);
        console.log(`🗄️ 메모리 캐시에 ${imageCache.size}개 이미지 저장됨`);
        
        // 🚀 전역 접근 가능하도록 캐시 노출
        window.preloadedImageCache = imageCache;
        window.getPreloadedImage = function(keyOrUrl) {
          const cached = imageCache.get(keyOrUrl);
          if (cached) {
            console.log(`🎯 캐시에서 이미지 반환: ${keyOrUrl}`);
            return cached.cloneNode(); // 복사본 반환으로 안전성 확보
          }
          console.warn(`⚠️ 캐시에서 이미지를 찾지 못함: ${keyOrUrl}`);
          return null;
        };
        
        // 완료 처리
        onPreloadingComplete(loadedCount, failedCount);
      }

      // DOM 로드 완료 시 프리로딩 시작 (기존 DOMContentLoaded 차단)
      document.addEventListener('DOMContentLoaded', (e) => {
        console.log('🎯 DOM 로드 완료 - 프리로딩 우선 실행');
        
        // 기존 DOMContentLoaded 이벤트 전파 차단
        e.stopImmediatePropagation();
        
        // 프리로딩 시작 (약간의 지연 후)
        setTimeout(() => {
          startSimpleImagePreloading();
        }, 100);
      });

      console.log('🚀 간단한 프리로더 스크립트 로드 완료');
    </script>
    
    <script src="script.js"></script>
    
    <!-- 디버깅용 간단한 테스트 -->
    <script>
      console.log('📝 HTML 로딩 완료');
      console.log('🔍 screens 객체 확인:', typeof window.screens);
      console.log('🔍 surveyData 객체 확인:', typeof window.surveyData);
      
      // 동영상 디버깅
      console.log('🎬 VIDEO_SOURCES 확인:', window.VIDEO_SOURCES);
      console.log('🎬 USE_VIDEO_BACKGROUND 확인:', window.USE_VIDEO_BACKGROUND);
      
      // 🖥️ 전체화면 함수들을 가장 먼저 정의 (전역 접근 가능)
      // 전체화면 토글 함수 (태블릿 최적화 개선)
      function toggleFullscreen() {
        console.log('🖥️ 전체화면 토글 함수 호출됨!');
        
        const elem = document.documentElement;
        
        // 현재 전체화면 상태 확인
        const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
        console.log('🖥️ 현재 전체화면 상태:', isFullscreen);
        console.log('🖥️ 현재 화면 크기:', `${window.screen.width}x${window.screen.height}`);
        console.log('🖥️ 뷰포트 크기:', `${window.innerWidth}x${window.innerHeight}`);
        
        if (isFullscreen) {
          // 전체화면 해제 (안전하게)
          console.log('🖥️ 전체화면 해제 시도');
          if (document.exitFullscreen) {
            document.exitFullscreen().catch(err => {
              console.warn('🖥️ 전체화면 해제 실패:', err);
            });
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          }
        } else {
          // 전체화면 진입 (안전하게)
          console.log('🖥️ 전체화면 진입 시도');
          
          // 맥북 크롬 호환을 위한 안전한 요청
          if (elem.requestFullscreen) {
            elem.requestFullscreen().then(() => {
              console.log('🖥️ ✅ 전체화면 진입 성공');
            }).catch(err => {
              console.warn('🖥️ 전체화면 진입 실패:', err);
              // navigationUI 옵션 없이 재시도
              elem.requestFullscreen().catch(err2 => {
                console.error('🖥️ 전체화면 진입 완전 실패:', err2);
              });
            });
          } else if (elem.webkitRequestFullscreen) {
            // Safari/Chrome 구형 버전 지원
            elem.webkitRequestFullscreen();
          }
        }
      }
      
      // 전역으로 등록
      window.toggleFullscreen = toggleFullscreen;
      
      window.updateFullscreenButton = function(isFullscreen) {
        console.log('🖥️ 버튼 업데이트:', isFullscreen ? '전체화면 모드' : '일반 모드');
        
        const fullscreenBtn = document.getElementById('fullscreenToggle');
        if (!fullscreenBtn) {
          console.warn('🖥️ ⚠️ 전체화면 버튼을 찾을 수 없습니다');
          return;
        }
        
        try {
          if (isFullscreen) {
            fullscreenBtn.innerHTML = `
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M5 16H8V14H5V16ZM8 8H5V10H8V8ZM14 19H16V16H14V19ZM16 8V5H14V8H16ZM14 14H16V16H14V14ZM8 10H10V8H8V10ZM10 14V16H8V14H10ZM16 10H14V8H16V10Z" fill="currentColor"/>
              </svg>
            `;
            fullscreenBtn.title = '전체화면 해제';
          } else {
            fullscreenBtn.innerHTML = `
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M7 14H5V19H10V17H7V14Z" fill="currentColor"/>
                <path d="M5 10H7V7H10V5H5V10Z" fill="currentColor"/>
                <path d="M17 14H19V19H14V17H17V14Z" fill="currentColor"/>
                <path d="M14 5V7H17V10H19V5H14Z" fill="currentColor"/>
              </svg>
            `;
            fullscreenBtn.title = '전체화면 모드';
          }
          console.log('🖥️ ✅ 버튼 아이콘 업데이트 완료');
        } catch (error) {
          console.error('🖥️ ❌ 버튼 업데이트 실패:', error);
        }
      };
      
      // 전체화면 상태 변경 감지
      window.handleFullscreenChange = function() {
        const isFullscreen = !!(document.fullscreenElement || 
                               document.webkitFullscreenElement || 
                               document.mozFullScreenElement || 
                               document.msFullscreenElement);
        
        console.log(`🖥️ 전체화면 상태 변경 이벤트: ${isFullscreen ? '활성화' : '해제'}`);
        window.updateFullscreenButton(isFullscreen);
        
        if (isFullscreen) {
          document.body.classList.add('fullscreen-mode');
        } else {
          document.body.classList.remove('fullscreen-mode');
        }
      };
      
      // 전체화면 이벤트 리스너 등록
      document.addEventListener('fullscreenchange', window.handleFullscreenChange);
      document.addEventListener('webkitfullscreenchange', window.handleFullscreenChange);
      document.addEventListener('mozfullscreenchange', window.handleFullscreenChange);
      document.addEventListener('MSFullscreenChange', window.handleFullscreenChange);
      
      console.log('🖥️ 전체화면 함수들이 전역으로 정의되었습니다');
      
      // 🔊 홈 화면 사운드 토글 함수 (먼저 정의)
      function toggleVideoSound(event) {
        event.stopPropagation(); // ❗ 부모로 이벤트 전파 방지

        const video = document.getElementById("homeBackgroundVideo");
        const icon = document.getElementById("soundToggle");

        if (!video) {
          console.warn('🔊 홈 동영상 요소를 찾을 수 없습니다');
          return;
        }

        if (!icon) {
          console.warn('🔊 사운드 토글 버튼을 찾을 수 없습니다');
          return;
        }

        // 홈 동영상은 항상 음소거 상태 유지 (영상만, 소리 없음)
        video.muted = true;
        video.volume = 0;
        console.log('🎬 홈 동영상은 항상 음소거 유지 (영상만)');

        // 배경음악만 토글
        if (typeof toggleBackgroundMusic === 'function') {
          const isMusicEnabled = toggleBackgroundMusic();
          icon.textContent = isMusicEnabled ? "🔊" : "🔇";
          console.log(`🎵 배경음악만 ${isMusicEnabled ? '활성화' : '비활성화'}`);
        } else {
          console.warn('🎵 배경음악 토글 함수를 찾을 수 없습니다');
        }
      }

      // 전역에서 접근 가능하도록 설정
      window.toggleVideoSound = toggleVideoSound;
      
      // 🎵 배경 음악 자동 재생 시스템
      let backgroundAudio = null;
      let currentAudioIndex = 0;
      let isMusicEnabled = true; // 음악 활성화 상태 (전역 유지)
      let musicInteractionListenerAdded = false; // 중복 이벤트 리스너 방지
      
      // 🎙️ AI 음성 가이드 시스템 (한 번만 선언)
      let voiceAudio = null;
      let isVoiceEnabled = true;
      let isVoicePlaying = false;
      let userHasInteracted = false; // 사용자 상호작용 확인
      
      // ⏰ 자동 진행 시스템
      let autoProgressTimer = null;
      let countdownTimer = null;
      let currentCountdown = 0;
      let isAutoProgressActive = false;
      
      // 배경 음악 소스들 (동영상에서 오디오만 추출)
      const BACKGROUND_AUDIO_SOURCES = [
        'https://res.cloudinary.com/di2pd92t1/video/upload/v1748237173/Dunlopillo-Crash-Test-Flexibilitet-web_n045ph.mp4',
        'https://res.cloudinary.com/di2pd92t1/video/upload/v1748237657/Dunlopillo-Crash-Test-Stabilitet-web_mvxr27.mp4',
        'https://res.cloudinary.com/di2pd92t1/video/upload/v1748241410/Dunlopillo-Crash-Test-Allergivenlig-A%CC%8Andba%CC%8Ar-web_wxolsb.mp4'
      ];

      // 페이지별 음성 파일 매핑 (실제 로컬 파일 기준)
      const VOICE_SCRIPTS = {
        'page3': 'assets/voices/voice_page3.mp3',
        'page4': 'assets/voices/voice_page4.mp3', 
        'page5': 'assets/voices/voice_page5.mp3',
        'page6': 'assets/voices/voice_tip1.mp3',
        'page7': 'assets/voices/voice_page7.mp3',
        'page8': 'assets/voices/voice_page8.mp3',
        'page9': 'assets/voices/voice_tip2.mp3',
        'page10': 'assets/voices/voice_page10.mp3',
        'page11': 'assets/voices/voice_page11.mp3',
        'page12': 'assets/voices/voice_page12.mp3',
        'page13': 'assets/voices/voice_page13.mp3',
        'page14': 'assets/voices/voice_tip3.mp3',
        'page15': 'assets/voices/voice_page15.mp3',
        'page16-1': 'assets/voices/voice_tip4.mp3',
        'page16-2': 'assets/voices/voice_tip5.mp3', // voice_tip5로 변경
        'page17': 'assets/voices/voice_page17.mp3'
      };

      // 전역에서 접근 가능하도록 설정
      window.VOICE_SCRIPTS = VOICE_SCRIPTS;

      // ⏰ 자동 진행 설정 (페이지별)
      const AUTO_PROGRESS_CONFIG = {
        // 홈 화면: 자동 진행 비활성화 (수동 터치만 가능)
        'home': { hasVoice: false, delay: 0 },
        
        // 음성 안내 있는 페이지들 (음성 종료 후 5초)
        'page3': { hasVoice: true, delay: 9 },
        'page4': { hasVoice: true, delay: 30 },
        'page5': { hasVoice: true, delay: 5 },  // 별점1
        'page6': { hasVoice: true, delay: 9 },  // TIP1 - voice_tip1
        'page7': { hasVoice: true, delay: 30 },
        'page8': { hasVoice: true, delay: 5 }, // 별점2
        'page9': { hasVoice: true, delay: 9 },  // TIP2 - voice_tip2
        'page10': { hasVoice: true, delay: 5 },
        'page11': { hasVoice: true, delay: 30 }, // 1분 대기
        'page12': { hasVoice: true, delay: 5 }, // 별점3
        'page13': { hasVoice: true, delay: 30 }, // 제로지
        'page14': { hasVoice: true, delay: 5 },  // TIP3 - voice_tip3
        'page15': { hasVoice: true, delay: 30 }, // 다시 원래대로 ~ 플랫 버튼을 눌러주세요~
        'page16-1': { hasVoice: true, delay: 5 },  // TIP4 - voice_tip4
        'page16-2': { hasVoice: true, delay: 5 },  // TIP5 - voice_tip5
        'page17': { hasVoice: true, delay: 30 }, // 이제 리모컨을 사용하여 모션베드를 체험해보세요.
        
        // 음성 안내 없는 페이지들 (자동 진행)
        'page18': { hasVoice: false, delay: 5 },
        'page19': { hasVoice: false, delay: 30 } // 홈 버튼에도 30초 자동 진행 효과
        // page1, page2는 자동 진행 없음
      };

      function initBackgroundMusic() {
        // 배경 음악 요소 생성
        backgroundAudio = document.createElement('audio');
        backgroundAudio.loop = false; // 개별 트랙이 끝나면 다음으로
        backgroundAudio.volume = 1.0; // 최대 볼륨 (100%)
        backgroundAudio.preload = 'auto';
        
        // 첫 번째 소스 설정
        backgroundAudio.src = BACKGROUND_AUDIO_SOURCES[currentAudioIndex];
        
        // 재생 시작 로그 추가
        backgroundAudio.addEventListener('play', () => {
          console.log('🎵 [PLAY] 배경음악 재생 시작:', backgroundAudio.src);
          console.trace('🎵 [TRACE] 재생 호출 스택:');
        });
        
        // 트랙 종료 시 다음 트랙으로 자동 전환
        backgroundAudio.addEventListener('ended', () => {
          currentAudioIndex = (currentAudioIndex + 1) % BACKGROUND_AUDIO_SOURCES.length;
          backgroundAudio.src = BACKGROUND_AUDIO_SOURCES[currentAudioIndex];
          if (isMusicEnabled) {
            console.log('🎵 [AUTO] 다음 트랙 자동 재생:', backgroundAudio.src);
            backgroundAudio.play().catch(error => {
              console.warn('다음 트랙 재생 실패:', error);
            });
          }
        });
        
        // 전역에서 접근 가능하도록 설정
        window.backgroundAudio = backgroundAudio;
        window.isMusicEnabled = isMusicEnabled;
        window.backgroundMusicSystem = {
          audio: backgroundAudio,
          toggle: toggleBackgroundMusic,
          isEnabled: () => isMusicEnabled,
          syncWithHomeVideo: syncMusicWithHomeVideo
        };
        
        console.log('🎵 배경 음악 시스템 초기화 완료');
      }

      // 🎙️ AI 음성 가이드 시스템 초기화
      function initVoiceGuide() {
        // 이미 초기화된 경우 중복 방지
        if (voiceAudio) {
          console.warn('🎙️ ⚠️ voiceAudio가 이미 존재합니다 - 중복 초기화 방지');
          return;
        }
        
        voiceAudio = document.createElement('audio');
        voiceAudio.volume = 0.8; // 음성은 배경음악보다 크게
        voiceAudio.preload = 'auto';
        
        // 음성 재생 시작 로그 추가
        voiceAudio.addEventListener('play', () => {
          console.log('🎙️ [PLAY] 음성 가이드 재생 시작:', voiceAudio.src);
          console.trace('🎙️ [TRACE] 음성 재생 호출 스택:');
        });
        
        // 음성 로딩 완료
        voiceAudio.addEventListener('loadeddata', () => {
          console.log('🎙️ [DEBUG] 음성 파일 로드 완료:', voiceAudio.src);
        });

        // 음성 로딩 시작
        voiceAudio.addEventListener('loadstart', () => {
          console.log('🎙️ [DEBUG] 음성 파일 로딩 시작:', voiceAudio.src);
        });
        
        // 음성 재생 완료 시 배경음악 복구 + 자동 진행 시작
        voiceAudio.addEventListener('ended', () => {
          isVoicePlaying = false;
          restoreBackgroundMusicVolume();
          console.log('🎙️ 음성 가이드 재생 완료');
          
          // 음성 종료 후 자동 진행 시작
          const currentPage = getCurrentPageName();
          const config = AUTO_PROGRESS_CONFIG[currentPage];
          if (config && config.hasVoice) {
            console.log(`⏰ [AUTO] 음성 종료 → 자동 진행 시작 (${config.delay}초)`);
            startCountdown(config.delay);
          }
        });

        // 음성 재생 오류 처리
        voiceAudio.addEventListener('error', (e) => {
          console.error('🎙️ ❌ 음성 가이드 재생 실패:', e);
          console.error('🎙️ [ERROR] 오류 코드:', voiceAudio.error?.code);
          console.error('🎙️ [ERROR] 오류 메시지:', voiceAudio.error?.message);
          console.error('🎙️ [ERROR] 파일 경로:', voiceAudio.src);
          isVoicePlaying = false;
          restoreBackgroundMusicVolume();
        });

        // 전역 접근 가능하도록 설정
        window.voiceGuideSystem = {
          audio: voiceAudio,
          playVoiceForPage: playVoiceForPage,
          stopVoice: stopVoice,
          isEnabled: () => isVoiceEnabled,
          toggle: toggleVoiceGuide
        };

        // ⏰ 자동 진행 시스템도 전역 접근 가능하도록 설정
        window.startAutoProgress = startAutoProgress;
        window.clearAutoProgress = clearAutoProgress;
        window.AUTO_PROGRESS_CONFIG = AUTO_PROGRESS_CONFIG;

        console.log('🎙️ AI 음성 가이드 시스템 초기화 완료');
      }

      // ⏰ 자동 진행 시스템
      function startAutoProgress(pageName) {
        console.log(`⏰ [AUTO] 자동 진행 시작: ${pageName}`);
        
        // 기존 타이머들 정리
        clearAutoProgress();
        
        const config = AUTO_PROGRESS_CONFIG[pageName];
        if (!config || config.delay <= 0) {
          console.log(`⏰ [AUTO] 자동 진행 설정 없음 또는 delay가 0: ${pageName}`);
          return;
        }

        isAutoProgressActive = true;
        
        if (config.hasVoice && VOICE_SCRIPTS[pageName]) {
          // 음성 안내 페이지: 음성 종료 후 카운트다운 시작
          console.log(`⏰ [AUTO] 음성 종료 대기 중...`);
          // 음성 종료는 voiceAudio의 'ended' 이벤트에서 처리
        } else {
          // 일반 페이지: 즉시 카운트다운 시작
          startCountdown(config.delay);
        }
      }

      function startCountdown(seconds) {
        if (!isAutoProgressActive) return;
        
        console.log(`⏰ [AUTO] 카운트다운 시작: ${seconds}초`);
        currentCountdown = seconds;
        updateNextButtonText();
        
        countdownTimer = setInterval(() => {
          currentCountdown--;
          updateNextButtonText();
          
          if (currentCountdown <= 0) {
            clearAutoProgress();
            autoGoToNextPage();
          }
        }, 1000);
      }

      function updateNextButtonText() {
        // 다양한 버튼 클래스 시도 (홈 버튼 포함)
        const nextButton = document.querySelector('.nav-btn.next-btn') || 
                          document.querySelector('.navigation-button.next') ||
                          document.querySelector('button[onclick*="next()"]') ||
                          document.querySelector('.page19-home-btn') || // page19 홈 버튼
                          document.querySelector('button[onclick*="goHome()"]') || // goHome 버튼
                          document.querySelector('button'); // 일반 버튼
                          
        console.log(`⏰ [DEBUG] 다음/홈 버튼 찾기:`, nextButton);
        
        if (nextButton && isAutoProgressActive) {
          // 원래 텍스트 확인
          let originalText = '다음>';
          if (nextButton.textContent.includes('홈으로')) {
            originalText = '홈으로';
          } else if (nextButton.textContent.includes('다음')) {
            originalText = nextButton.textContent.includes('>') ? '다음>' : '다음';
          }
          
          // 타이머 텍스트 제거 - 원래 텍스트만 유지
          nextButton.textContent = originalText;
          
          // 부드러운 선형 프로그레스 효과 (회색 → 파란색)
          const totalSeconds = AUTO_PROGRESS_CONFIG[getCurrentPageName()]?.delay || 7;
          const progress = ((totalSeconds - currentCountdown) / totalSeconds) * 100;
          
          // 기존 배경색을 한 번만 저장
          if (!nextButton.dataset.originalBackground) {
            const computedStyle = window.getComputedStyle(nextButton);
            
            // 홈 버튼의 경우 회색 배경으로 강제 설정
            if (nextButton.textContent.includes('홈으로')) {
              nextButton.dataset.originalBackground = '#efefef';
              nextButton.dataset.originalBorder = computedStyle.border || '';
              nextButton.dataset.originalColor = '#000000';
            } else {
              nextButton.dataset.originalBackground = computedStyle.backgroundColor || '#1e40af';
              nextButton.dataset.originalBorder = computedStyle.border || '';
              nextButton.dataset.originalColor = computedStyle.color || '';
            }
            
            console.log(`⏰ [DEBUG] 원래 스타일 저장:`, {
              background: nextButton.dataset.originalBackground,
              border: nextButton.dataset.originalBorder,
              color: nextButton.dataset.originalColor
            });
          }
          
          // 홈 버튼의 경우 색상 조정
          let baseColor = '#6b7280'; // 회색 (홈 버튼용)
          let targetColor = '#1e40af'; // 파란색 (홈 버튼용)
          
          // 다른 페이지의 네비게이션 버튼 색상
          if (!nextButton.textContent.includes('홈으로')) {
            baseColor = '#6b7280'; // 기본 회색
            targetColor = '#1e40af'; // 기본 파란색
          }
          
          // 부드러운 그라데이션으로 왼쪽부터 채우기
          nextButton.style.background = `linear-gradient(
            to right, 
            ${targetColor} 0%, 
            ${targetColor} ${progress}%, 
            ${baseColor} ${progress}%, 
            ${baseColor} 100%
          )`;
          
          // 부드러운 전환 효과 추가
          nextButton.style.transition = 'background 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
          nextButton.style.backgroundSize = '100% 100%';
          nextButton.style.backgroundRepeat = 'no-repeat';
          
          console.log(`⏰ [DEBUG] 프로그레스 버튼 업데이트: ${nextButton.textContent}, 진행도: ${progress.toFixed(1)}% (${baseColor}→${targetColor})`);
        } else {
          console.log(`⏰ [DEBUG] 다음/홈 버튼을 찾을 수 없음 또는 자동 진행 비활성화`);
        }
      }

      function autoGoToNextPage() {
        console.log(`⏰ [AUTO] 자동으로 다음 페이지 이동`);
        
        // 다양한 방법으로 버튼 찾기 (홈 버튼 포함)
        const nextButton = document.querySelector('.nav-btn.next-btn') || 
                          document.querySelector('.navigation-button.next') ||
                          document.querySelector('button[onclick*="next()"]') ||
                          document.querySelector('.page19-home-btn') || // page19 홈 버튼
                          document.querySelector('button[onclick*="goHome()"]'); // goHome 버튼
                          
        console.log(`⏰ [DEBUG] 자동 클릭할 버튼:`, nextButton);
        
        if (nextButton && !nextButton.disabled) {
          nextButton.click();
        } else {
          // 버튼을 못 찾으면 직접 함수 호출
          const currentPage = getCurrentPageName();
          if (currentPage === 'page19' && typeof window.goHome === 'function') {
            window.goHome();
            console.log(`⏰ [AUTO] goHome() 직접 호출`);
          } else if (window.app && typeof window.app.next === 'function') {
            window.app.next();
            console.log(`⏰ [AUTO] app.next() 직접 호출`);
          }
        }
      }

      function clearAutoProgress() {
        if (autoProgressTimer) {
          clearTimeout(autoProgressTimer);
          autoProgressTimer = null;
        }
        
        if (countdownTimer) {
          clearInterval(countdownTimer);
          countdownTimer = null;
        }
        
        isAutoProgressActive = false;
        currentCountdown = 0;
        
        // 버튼 스타일 복구 (부드러운 전환 효과 포함)
        const nextButton = document.querySelector('.nav-btn.next-btn') || 
                          document.querySelector('.navigation-button.next') ||
                          document.querySelector('button[onclick*="next()"]') ||
                          document.querySelector('.page19-home-btn') || // page19 홈 버튼
                          document.querySelector('button[onclick*="goHome()"]'); // goHome 버튼
                          
        if (nextButton) {
          // 원래 텍스트로 복구 (홈 버튼은 "홈으로" 유지)
          let baseText = '다음>';
          if (nextButton.classList.contains('page19-home-btn') || nextButton.textContent.includes('홈으로')) {
            baseText = '홈으로';
          } else if (nextButton.textContent.includes('>')) {
            baseText = '다음>';
          } else {
            baseText = '다음';
          }
          nextButton.textContent = baseText;
          
          // 부드러운 스타일 복구
          if (nextButton.dataset.originalBackground) {
            // 부드러운 전환으로 원래 색상으로 복구
            nextButton.style.transition = 'background 0.5s ease-out';
            nextButton.style.background = nextButton.dataset.originalBackground;
            console.log(`⏰ [DEBUG] 부드러운 배경색 복구: ${nextButton.dataset.originalBackground}`);
          } else {
            // 기본 스타일로만 초기화
            nextButton.style.background = '';
          }
          
          // 프로그레스 관련 스타일 정리 (지연 실행으로 부드러운 효과)
          setTimeout(() => {
            nextButton.style.backgroundSize = '';
            nextButton.style.backgroundRepeat = '';
            nextButton.style.transition = '';
          }, 500);
          
          console.log(`⏰ [DEBUG] 버튼 스타일 부드럽게 복구: ${nextButton.textContent}`);
        }
        
        console.log(`⏰ [AUTO] 자동 진행 시스템 정리 완료`);
      }

      function getCurrentPageName() {
        return window.app?.getCurrentScreen?.() || 'home';
      }

      // 간단한 page3 음성 테스트 함수
      function testPage3Voice() {
        console.log('🧪 [TEST] page3 음성 테스트 시작');
        
        // 직접 오디오 객체 생성하여 테스트
        const testAudio = new Audio('assets/voices/voice_page3.mp3');
        testAudio.volume = 0.8;
        
        testAudio.addEventListener('loadeddata', () => {
          console.log('🧪 [TEST] 음성 파일 로드 성공');
        });
        
        testAudio.addEventListener('error', (e) => {
          console.error('🧪 [TEST] 음성 파일 로드 실패:', e);
          console.error('🧪 [TEST] 파일 경로:', testAudio.src);
        });
        
        testAudio.play().then(() => {
          console.log('🧪 [TEST] ✅ 음성 재생 성공!');
        }).catch(error => {
          console.error('🧪 [TEST] ❌ 음성 재생 실패:', error);
        });
        
        // 전역에서 접근 가능하도록
        window.testAudio = testAudio;
      }

      // 페이지별 음성 가이드 재생 (음소거 상태 확인 추가)
      function playVoiceForPage(pageName) {
        console.log(`🎙️ [DEBUG] playVoiceForPage 호출됨: ${pageName}`);
        console.log(`🎙️ [DEBUG] userHasInteracted: ${userHasInteracted}`);
        console.log(`🎙️ [DEBUG] isVoiceEnabled: ${isVoiceEnabled}`);
        console.log(`🎙️ [DEBUG] VOICE_SCRIPTS[${pageName}]: ${VOICE_SCRIPTS[pageName]}`);
        console.log(`🎙️ [DEBUG] voiceAudio 객체: ${!!voiceAudio}`);
        
        // 사용자 상호작용 체크를 일시적으로 비활성화 (테스트용)
        console.log(`🎙️ [INFO] 사용자 상호작용 체크 건너뛰기 (테스트 모드)`);
        
        // 음성 가이드 활성화 상태 확인
        if (!isVoiceEnabled) {
          console.log(`🎙️ 음성 가이드 비활성화됨`);
          return;
        }
        
        // 배경음악 시스템 상태 확인 (음소거 상태일 때 음성도 비활성화)
        if (window.backgroundMusicSystem && !window.backgroundMusicSystem.isEnabled()) {
          console.log(`🎙️ 음소거 상태로 인해 음성 가이드 건너뛰기`);
          return;
        }
        
        // 홈 동영상 음소거 상태 확인
        const homeVideo = document.getElementById('homeBackgroundVideo');
        if (homeVideo && homeVideo.muted) {
          console.log(`🎙️ 홈 동영상 음소거로 인해 음성 가이드 건너뛰기`);
          return;
        }
        
        if (!VOICE_SCRIPTS[pageName]) {
          console.log(`🎙️ 음성 가이드 없음: ${pageName}`);
          return;
        }

        if (!voiceAudio) {
          console.error(`🎙️ [ERROR] voiceAudio 객체가 초기화되지 않음`);
          return;
        }

        const voiceFile = VOICE_SCRIPTS[pageName];
        console.log(`🎙️ [DEBUG] 음성 파일 경로: ${voiceFile}`);
        
        // 이전 음성 정지
        if (isVoicePlaying) {
          console.log(`🎙️ [DEBUG] 이전 음성 정지`);
          stopVoice();
        }

        // 배경음악 볼륨 줄이기
        lowerBackgroundMusicVolume();

        // 음성 파일 로드 및 재생
        voiceAudio.src = voiceFile;
        console.log(`🎙️ [DEBUG] 음성 파일 src 설정 완료: ${voiceAudio.src}`);
        
        // 약간의 지연 후 재생 시도
        setTimeout(() => {
          voiceAudio.play().then(() => {
            isVoicePlaying = true;
            console.log(`🎙️ ✅ 음성 가이드 재생 시작: ${pageName}`);
          }).catch(error => {
            console.error(`🎙️ ❌ 음성 가이드 재생 실패: ${pageName}`, error);
            console.error(`🎙️ [ERROR] 파일 경로: ${voiceFile}`);
            console.error(`🎙️ [ERROR] 상세 오류:`, error.message);
            restoreBackgroundMusicVolume();
          });
        }, 100);
      }

      // 음성 가이드 정지
      function stopVoice() {
        if (voiceAudio) {
          voiceAudio.pause();
          voiceAudio.currentTime = 0;
          isVoicePlaying = false;
          restoreBackgroundMusicVolume();
          console.log('🎙️ 음성 가이드 정지');
        }
      }

      // 음성 가이드 토글
      function toggleVoiceGuide() {
        isVoiceEnabled = !isVoiceEnabled;
        if (!isVoiceEnabled && isVoicePlaying) {
          stopVoice();
        }
        console.log(`🎙️ 음성 가이드 ${isVoiceEnabled ? '활성화' : '비활성화'}`);
        return isVoiceEnabled;
      }

      // 배경음악 볼륨 줄이기 (음성 재생 중)
      function lowerBackgroundMusicVolume() {
        if (backgroundAudio && isMusicEnabled) {
          backgroundAudio.volume = 0.3; // 30%로 줄임
          console.log('🔉 배경음악 볼륨 감소 (음성 재생 중)');
        }
      }

      // 배경음악 볼륨 복구
      function restoreBackgroundMusicVolume() {
        if (backgroundAudio && isMusicEnabled) {
          backgroundAudio.volume = 1.0; // 원래 볼륨으로 복구
          console.log('🔊 배경음악 볼륨 복구');
        }
      }

      // 배경 음악 토글 함수 (백업 버전과 동일한 간단한 로직)
      function toggleBackgroundMusic() {
        console.log('🔊 toggleBackgroundMusic 함수 호출됨');
        console.log('🔊 현재 상태:', { isMusicEnabled, backgroundAudio: !!backgroundAudio });
        
        if (isMusicEnabled) {
          // 음악 끄기
          if (backgroundAudio) {
            backgroundAudio.pause();
          }
          isMusicEnabled = false;
          console.log('🔇 배경 음악 비활성화');
        } else {
          // 음악 켜기
          isMusicEnabled = true;
          if (backgroundAudio) {
            backgroundAudio.play().then(() => {
              console.log('🎵 배경 음악 활성화');
            }).catch(error => {
              console.warn('배경 음악 재생 실패:', error);
            });
          }
        }
        
        // 아이콘 업데이트
        const soundToggle = document.getElementById('soundToggle');
        if (soundToggle) {
          soundToggle.textContent = isMusicEnabled ? "🔊" : "🔇";
        }
        
        return isMusicEnabled;
      }

      // 전역에 함수 노출 (함수 정의 직후 바로 실행)
      window.toggleBackgroundMusic = toggleBackgroundMusic;
      
      // 더 이상 홈 동영상과 동기화하지 않음 (배경음악만 독립 제어)
      function syncMusicWithHomeVideo() {
        console.log('🔄 [INFO] 홈 동영상과 배경음악은 이제 독립적으로 작동');
        return isMusicEnabled;
      }
      
      // 사용자 상호작용 후 자동 음악 시작 (중복 실행 방지 강화)
      function startBackgroundMusicOnInteraction() {
        console.log('🎵 [INTERACTION] 사용자 상호작용으로 음악 시작 시도');
        
        // 이미 음악이 재생 중이면 절대 건드리지 않음
        if (backgroundAudio && !backgroundAudio.paused) {
          console.log('🎵 배경 음악이 이미 재생 중 - 아무것도 하지 않음');
          return;
        }
        
        // 음악이 활성화 상태이고 정지되어 있을 때만 시작
        if (isMusicEnabled && backgroundAudio && backgroundAudio.paused) {
          console.log('🎵 [INTERACTION] 음악 시작 가능 - 재생 시도');
          backgroundAudio.play().then(() => {
            console.log('🎵 [INTERACTION] 배경 음악 시작 성공');
          }).catch(error => {
            console.warn('🎵 [INTERACTION] 배경 음악 시작 실패:', error);
          });
        } else {
          console.log('🎵 [INTERACTION] 음악 비활성화 또는 이미 재생 중 - 건너뛰기');
        }
      }

      // 홈 화면 동영상 오디오 음소거 함수
      function muteHomeVideo() {
        setTimeout(() => {
          const homeVideo = document.getElementById('homeBackgroundVideo');
          if (homeVideo) {
            homeVideo.muted = true; // 홈 동영상 음소거
            homeVideo.volume = 0;
            console.log('🔇 홈 화면 동영상 오디오 음소거');
            
            // 배경 음악도 함께 비활성화
            syncMusicWithHomeVideo();
          }
        }, 1000);
      }

      window.updateFullscreenButton = function(isFullscreen) {
        const fullscreenBtn = document.getElementById('fullscreenToggle');
        if (!fullscreenBtn) return;
        
        if (isFullscreen) {
          fullscreenBtn.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M5 16H8V14H5V16ZM8 8H5V10H8V8ZM14 19H16V16H14V19ZM16 8V5H14V8H16ZM14 14H16V16H14V14ZM8 10H10V8H8V10ZM10 14V16H8V14H10ZM16 10H14V8H16V10Z" fill="currentColor"/>
            </svg>
          `;
          fullscreenBtn.title = '전체화면 해제';
        } else {
          fullscreenBtn.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M7 14H5V19H10V17H7V14Z" fill="currentColor"/>
              <path d="M5 10H7V7H10V5H5V10Z" fill="currentColor"/>
              <path d="M17 14H19V19H14V17H17V14Z" fill="currentColor"/>
              <path d="M14 5V7H17V10H19V5H14Z" fill="currentColor"/>
            </svg>
          `;
          fullscreenBtn.title = '전체화면 모드';
        }
      };

      // 전체화면 상태 변경 감지 (태블릿 최적화 개선)
      window.handleFullscreenChange = function() {
        const isFullscreen = !!(document.fullscreenElement || 
                               document.webkitFullscreenElement || 
                               document.mozFullScreenElement || 
                               document.msFullscreenElement);
        
        console.log(`🖥️ 전체화면 상태 변경 이벤트: ${isFullscreen ? '활성화' : '해제'}`);
        window.updateFullscreenButton(isFullscreen);
        
        if (isFullscreen) {
          document.body.classList.add('fullscreen-mode');
          
          // 태블릿 최적화: 1280x800 기준으로 화면에 맞게 스케일 계산
          const targetWidth = 1280;
          const targetHeight = 800;
          
          // 실제 뷰포트 크기 사용 (브라우저 UI 제외)
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          
          console.log(`🖥️ 뷰포트 크기: ${viewportWidth}x${viewportHeight}`);
          console.log(`🖥️ 타겟 크기: ${targetWidth}x${targetHeight}`);
          
          // 태블릿에서 좌우를 화면에 딱 맞게: 가로 기준으로 스케일 결정
          let scale;
          
          // 태블릿인지 확인 (일반적인 태블릿 해상도 범위)
          const isTablet = (viewportWidth >= 768 && viewportWidth <= 1366) && 
                          (viewportHeight >= 600 && viewportHeight <= 1024);
          
          if (isTablet) {
            // 태블릿: 화면을 완전히 꽉 채우기 위해 더 큰 스케일 선택
            const scaleX = viewportWidth / targetWidth;
            const scaleY = viewportHeight / targetHeight;
            scale = Math.max(scaleX, scaleY); // 더 큰 스케일로 여백 완전 제거
            console.log(`🖥️ 태블릿 모드: max(${scaleX.toFixed(3)}, ${scaleY.toFixed(3)}) = ${scale.toFixed(3)} (화면 완전히 채우기)`);
            console.log(`🖥️ [DEBUG] 화면 크기: ${viewportWidth}x${viewportHeight}, 타겟: ${targetWidth}x${targetHeight}`);
          } else {
            // 데스크톱: 기존 방식 (비율 유지하면서 전체 화면 맞춤)
            const scaleX = viewportWidth / targetWidth;
            const scaleY = viewportHeight / targetHeight;
            scale = Math.min(scaleX, scaleY);
            console.log(`🖥️ 데스크톱 모드: min(${scaleX.toFixed(3)}, ${scaleY.toFixed(3)}) = ${scale.toFixed(3)}`);
          }
          
          // 최소 스케일 보장 (너무 작아지지 않도록)
          scale = Math.max(scale, 0.8);
          
          console.log(`🖥️ 최종 스케일: ${scale.toFixed(3)} (${isTablet ? '태블릿' : '데스크톱'} 모드)`);
          
          // CSS 변수로 스케일 값 설정
          document.documentElement.style.setProperty('--fullscreen-scale', scale);
          
          // 태블릿에서 추가 스케일링 확인을 위한 디버깅
          if (isTablet) {
            console.log(`🖥️ [DEBUG] 태블릿 전체화면 모드 활성화`);
            console.log(`🖥️ [DEBUG] 계산된 스케일: ${scale}`);
            console.log(`🖥️ [DEBUG] CSS 변수 설정: --fullscreen-scale = ${scale}`);
            
            // 스케일이 제대로 적용되는지 확인
            setTimeout(() => {
              const screenContainer = document.querySelector('.screen-container');
              if (screenContainer) {
                const computedStyle = window.getComputedStyle(screenContainer);
                console.log(`🖥️ [DEBUG] 실제 적용된 transform:`, computedStyle.transform);
                console.log(`🖥️ [DEBUG] 컨테이너 크기:`, {
                  width: screenContainer.offsetWidth,
                  height: screenContainer.offsetHeight
                });
              }
            }, 100);
          }
        } else {
          document.body.classList.remove('fullscreen-mode');
          // 스케일 초기화
          document.documentElement.style.removeProperty('--fullscreen-scale');
        }
      };

      // 전체화면 이벤트 리스너 등록
      document.addEventListener('fullscreenchange', window.handleFullscreenChange);
      document.addEventListener('webkitfullscreenchange', window.handleFullscreenChange);
      document.addEventListener('mozfullscreenchange', window.handleFullscreenChange);
      document.addEventListener('MSFullscreenChange', window.handleFullscreenChange);

      // 페이지 로드 완료 후 추가 설정 (fullscreen-test.html 방식)
      window.addEventListener('load', function() {
        console.log('🖥️ 페이지 로드 완료 - 전체화면 함수 확인');
        console.log('🖥️ window.toggleFullscreen:', typeof window.toggleFullscreen);
        
        // 전체화면 지원 확인
        const elem = document.documentElement;
        const support = elem.requestFullscreen ? 'Standard API ✅' :
                       elem.webkitRequestFullscreen ? 'WebKit API ✅' :
                       elem.mozRequestFullScreen ? 'Mozilla API ✅' :
                       elem.msRequestFullscreen ? 'MS API ✅' : 'Not Supported ❌';
        console.log('🖥️ 전체화면 지원:', support);
      });
      
      // 전체화면 기능 테스트 함수
      window.testFullscreen = function() {
        console.log('🖥️ 전체화면 기능 테스트 시작');
        console.log('🖥️ 브라우저 지원 여부:', {
          requestFullscreen: !!document.documentElement.requestFullscreen,
          webkitRequestFullscreen: !!document.documentElement.webkitRequestFullscreen,
          mozRequestFullScreen: !!document.documentElement.mozRequestFullScreen,
          msRequestFullscreen: !!document.documentElement.msRequestFullscreen
        });
        
        const fullscreenBtn = document.getElementById('fullscreenToggle');
        console.log('🖥️ 전체화면 버튼 존재:', !!fullscreenBtn);
        
        if (fullscreenBtn) {
          console.log('🖥️ 버튼 클릭 이벤트 수동 발생');
          fullscreenBtn.click();
        }
      };

      // 페이지 로드 완료 후 자동 초기화 및 재생
      window.addEventListener('load', () => {
        console.log('🎬 페이지 로드 완료 - 시스템 초기화 시작');
        
        initBackgroundMusic();
        initVoiceGuide(); // 음성 가이드 시스템 초기화
        // muteHomeVideo(); // 자동 음소거 제거 - 사용자가 직접 제어하도록 변경
        
        // 🔊 사운드 토글 버튼 초기 상태 설정
        setTimeout(() => {
          const soundToggle = document.getElementById('soundToggle');
          if (soundToggle) {
            soundToggle.textContent = isMusicEnabled ? "🔊" : "🔇";
            console.log('🔊 사운드 토글 버튼 초기 상태 설정:', isMusicEnabled ? '활성화' : '비활성화');
          }
        }, 1000);
        
        // 전체화면 버튼 초기 상태 설정
        updateFullscreenButton(false);
        
        // 🖥️ 키오스크 모드: 기본 전체화면 설정
        initKioskMode();
        
        // 🖥️ 전체화면 버튼 확인 (홈 화면 로드 후)
        setTimeout(() => {
          const fullscreenBtn = document.getElementById('fullscreenToggle');
          console.log('🖥️ 전체화면 버튼 존재 여부:', !!fullscreenBtn);
          console.log('🖥️ window.toggleFullscreen 함수:', typeof window.toggleFullscreen);
          
          if (fullscreenBtn) {
            console.log('🖥️ 전체화면 버튼 onclick 속성:', fullscreenBtn.getAttribute('onclick'));
            
            // 수동으로 클릭 이벤트 리스너 추가
            fullscreenBtn.addEventListener('click', function(e) {
              console.log('🖥️ 버튼 클릭 이벤트 감지됨!');
              e.preventDefault();
              if (typeof window.toggleFullscreen === 'function') {
                window.toggleFullscreen();
              } else {
                console.error('🖥️ toggleFullscreen 함수를 찾을 수 없음');
              }
            });
            console.log('🖥️ ✅ 전체화면 버튼에 이벤트 리스너 추가 완료');
          } else {
            console.error('🖥️ ❌ 전체화면 버튼을 찾을 수 없음');
          }
        }, 2000); // 홈 화면 로드 후 2초 대기            // 사용자 상호작용 감지 (버튼 클릭, 터치, 키보드 등)
            const interactionEvents = ['click', 'touchstart', 'keydown'];
            
            function markUserInteraction() {
              if (!userHasInteracted) {
                userHasInteracted = true;
                console.log('👆 사용자 상호작용 감지됨 - 음성 재생 가능');
              }
            }
            
            // 상호작용 이벤트 리스너 등록
            interactionEvents.forEach(event => {
              document.addEventListener(event, markUserInteraction, { once: true });
            });        
            
        // 첫 번째 클릭이나 터치에서 음악 자동 시작 (중복 방지 강화)
        if (!musicInteractionListenerAdded) {
          // 한 번만 실행되는 이벤트 리스너 (once: true)
          const interactionHandler = () => {
            console.log('🎵 [ONCE] 첫 번째 사용자 상호작용 감지');
            // 이미 음악이 재생 중이 아닐 때만 시작
            if (backgroundAudio && backgroundAudio.paused && isMusicEnabled) {
              startBackgroundMusicOnInteraction();
            }
            musicInteractionListenerAdded = true; // 완전히 처리된 후 플래그 설정
          };
          
          document.addEventListener('click', interactionHandler, { once: true });
          document.addEventListener('touchstart', interactionHandler, { once: true });
          console.log('🎵 음악 상호작용 이벤트 리스너 등록됨 (once: true)');
        }
      });

      // 🖥️ 키오스크 모드 초기화 (맥북 크롬 호환 버전)
      function initKioskMode() {
        console.log('🖥️ 키오스크 모드 초기화 시작 (안전 모드)');
        
        // 전체화면 지원 여부 확인
        const elem = document.documentElement;
        const fullscreenSupported = !!(elem.requestFullscreen || 
                                      elem.webkitRequestFullscreen || 
                                      elem.mozRequestFullScreen || 
                                      elem.msRequestFullscreen);
        
        console.log('🖥️ 전체화면 지원:', fullscreenSupported);
        
        if (!fullscreenSupported) {
          console.warn('🖥️ ⚠️ 이 브라우저는 전체화면 API를 지원하지 않습니다');
          // 전체화면 버튼 비활성화
          const fullscreenBtn = document.getElementById('fullscreenToggle');
          if (fullscreenBtn) {
            fullscreenBtn.style.opacity = '0.5';
            fullscreenBtn.style.cursor = 'not-allowed';
            fullscreenBtn.title = '전체화면을 지원하지 않는 브라우저입니다';
          }
        }
        
        // 화면 회전 잠금 (모바일에서만)
        if (window.innerWidth <= 1024 && screen.orientation && screen.orientation.lock) {
          screen.orientation.lock('landscape').catch(err => {
            console.log('🔄 화면 회전 잠금 실패 (권한 필요):', err);
          });
        }
        
        // 더블탭 줌 방지 (모바일에서만)
        if (window.innerWidth <= 1024) {
          let lastTouchEnd = 0;
          document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
              event.preventDefault();
            }
            lastTouchEnd = now;
          }, false);
        }
        
        // F11키로 전체화면 토글 (데스크톱에서만)
        if (window.innerWidth > 1024) {
          document.addEventListener('keydown', function(e) {
            if (e.key === 'F11') {
              e.preventDefault();
              toggleFullscreen();
            }
          });
        }
        
        console.log('🖥️ 키오스크 모드 설정 완료 (안전 모드)');
      }

      // 전체화면 요청 (간소화된 버전)
      function requestFullscreenMode() {
        if (!document.fullscreenElement) {
          const elem = document.documentElement;
          
          console.log('🖥️ 전체화면 모드 요청 시작...');
          
          if (elem.requestFullscreen) {
            elem.requestFullscreen().then(() => {
              console.log('🖥️ ✅ 전체화면 모드 활성화');
            }).catch(err => {
              console.log('🖥️ ❌ 전체화면 요청 실패:', err);
            });
          } else if (elem.webkitRequestFullscreen) { // Safari
            elem.webkitRequestFullscreen();
          } else if (elem.msRequestFullscreen) { // IE/Edge
            elem.msRequestFullscreen();
          } else if (elem.mozRequestFullScreen) { // Firefox
            elem.mozRequestFullScreen();
          }
        }
      }
      
      // 5초 후 동영상 상태 확인
      setTimeout(() => {
        const video = document.getElementById('homeBackgroundVideo');
        console.log('🎬 동영상 요소:', video);
        if (video) {
          console.log('🎬 동영상 src:', video.src);
          console.log('🎬 동영상 readyState:', video.readyState);
          console.log('🎬 동영상 networkState:', video.networkState);
        }
        
        const videoContainer = document.querySelector('.home-video-container');
        console.log('🎬 동영상 컨테이너:', videoContainer);
        
        // 배경 음악 상태 확인
        console.log('🎵 배경 음악 상태:', {
          currentTrack: currentAudioIndex,
          volume: backgroundAudio?.volume,
          src: backgroundAudio?.src
        });
      }, 5000);
      
      // 화면 크기 디버그 정보 업데이트
      function updateScreenSizeDebug() {
        const screenContainer = document.querySelector('.screen-container');
        const screenSizeElement = document.getElementById('screenSize');
        if (screenContainer && screenSizeElement) {
          const width = screenContainer.offsetWidth;
          const height = screenContainer.offsetHeight;
          const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
          screenSizeElement.textContent = `${width}x${height} ${isFullscreen ? '(전체화면)' : '(일반화면)'}`;
        }
      }
      
      // 초기 크기 표시
      updateScreenSizeDebug();
      
      // 전체화면 변경 감지
      document.addEventListener('fullscreenchange', updateScreenSizeDebug);
      document.addEventListener('webkitfullscreenchange', updateScreenSizeDebug);
      document.addEventListener('mozfullscreenchange', updateScreenSizeDebug);
      document.addEventListener('MSFullscreenChange', updateScreenSizeDebug);
      
      // 윈도우 리사이즈 감지
      window.addEventListener('resize', updateScreenSizeDebug);
      
      // 주기적으로 업데이트 (추가 안전장치)
      setInterval(updateScreenSizeDebug, 1000);
    </script>

    <!-- � URL에서 디바이스 ID 추출 -->
    <script>
      // URL 경로에서 디바이스 ID 추출 (예: /TABLET_01)
      function getDeviceIdFromUrl() {
        console.log('🔍 URL 경로에서 디바이스 ID 추출 시도');
        const path = window.location.pathname;
        console.log('🔍 현재 URL 경로:', path);
        
        // 경로가 단순 슬래시나 index.html인 경우 제외
        if (path === '/' || path === '/index.html') {
          console.log('🔍 기본 경로 - 디바이스 ID 추출 건너뛰기');
          return null;
        }
        
        // 경로에서 슬래시 제거하고 ID 추출
        const deviceId = path.replace(/^\//, '').replace(/\/index\.html$/, '');
        
        if (deviceId) {
          console.log('🔍 URL에서 디바이스 ID 추출됨:', deviceId);
          
          // localStorage에 ID 저장
          localStorage.setItem('dunlopillo_device_id', deviceId);
          localStorage.setItem('dunlopillo_auto_device_id', deviceId);
          
          console.log('🔍 디바이스 ID 저장됨:', deviceId);
          return deviceId;
        }
        
        return null;
      }
      
      // 페이지 로드 시 자동 실행
      window.addEventListener('DOMContentLoaded', () => {
        getDeviceIdFromUrl();
      });
    </script>
    
    <!-- �🚀 PWA Service Worker 등록 -->
    <script>
      // Service Worker 등록
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js')
            .then((registration) => {
              console.log('✅ Service Worker 등록 성공:', registration.scope);
              
              // 업데이트 감지
              registration.addEventListener('updatefound', () => {
                console.log('🔄 Service Worker 업데이트 감지');
                const newWorker = registration.installing;
                
                newWorker.addEventListener('statechange', () => {
                  if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                    console.log('🆕 새 버전 사용 가능 - 페이지 새로고침 권장');
                    
                    // 자동 업데이트 (선택적)
                    if (confirm('새 버전이 사용 가능합니다. 지금 업데이트하시겠습니까?')) {
                      newWorker.postMessage({ type: 'SKIP_WAITING' });
                      window.location.reload();
                    }
                  }
                });
              });
            })
            .catch((error) => {
              console.error('❌ Service Worker 등록 실패:', error);
            });
        });

        // Service Worker 메시지 수신
        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data && event.data.type === 'SW_UPDATED') {
            window.location.reload();
          }
        });
      } else {
        console.warn('⚠️ Service Worker를 지원하지 않는 브라우저입니다');
      }

      // 오프라인/온라인 상태 감지
      window.addEventListener('online', () => {
        console.log('🌐 온라인 상태');
        showConnectionStatus('온라인', '#4CAF50');
      });

      window.addEventListener('offline', () => {
        console.log('📡 오프라인 상태');
        showConnectionStatus('오프라인 모드', '#FF9800');
      });

      function showConnectionStatus(message, color) {
        const statusDiv = document.createElement('div');
        statusDiv.textContent = message;
        statusDiv.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: ${color};
          color: white;
          padding: 8px 16px;
          border-radius: 20px;
          font-size: 14px;
          font-weight: bold;
          z-index: 10000;
          animation: slideDown 0.3s ease;
        `;
        
        document.body.appendChild(statusDiv);
        
        setTimeout(() => {
          statusDiv.style.animation = 'slideUp 0.3s ease';
          setTimeout(() => statusDiv.remove(), 300);
        }, 3000);
      }

      // CSS 애니메이션 추가
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideDown {
          from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
          to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        @keyframes slideUp {
          from { transform: translateX(-50%) translateY(0); opacity: 1; }
          to { transform: translateX(-50%) translateY(-100%); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    </script>
  </body>
</html>
